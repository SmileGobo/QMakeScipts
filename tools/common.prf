load(tools/project)
load(tools/depend)
load(tools/util)


#инициализация вызвать в начале проекта
#пока используется include(settings.pri)
defineTest(Init){
    OUT_DIR = $$1
    isEmpty(OUT_DIR){
        OUT_DIR=$$absolute_path($${_PRO_FILE_PWD_}/../build)
        warning($$module_name(): default OUT_DIR: $$OUT_DIR)
    }

    
    CONFIG += no_include_pwd
    CONFIG += C++11

    CONFIG(debug, debug|release) {
        BUILD_TYPE=debug
        DEFINES+= _DEBUG            #в коде тоже должны знать что у нас отладка
        LIB_SUFFIX=d
    } else {
        LIB_SUFFIX=                 #суффикс для библиотек d - для дебаг и пустой для release
        BUILD_TYPE=release          #тип сборки отладочная или релизная
    }
    #настройки проекта глобальные
    #базовая дирректория может быть переопределена в user_settings

    BUILD_PATH=$${OUT_DIR}/$$_TARGET
    #дирректория для складирования модулей подсистем
    LIB_DIR=$$BUILD_PATH/lib 
    #дирректория для разделеной линковки подсистем и тестов и приложений
    OBJ_DIR=$$BUILD_PATH/obj/$$module_name() 
    #дира для исполняемых файлов 
    BIN_DIR=$$BUILD_PATH/bin               
    win32{
        DEFINES+=WIN32_
        QMAKE_CXXFLAGS += /wd4482  #отключает некорректный варининг в 10 студии
    }

    include($$USER_SETTINGS)
    !isEmpty(EXTERNAL_LIB_PATH){
        export(EXTERNAL_LIB_PATH)
    }
    !isEmpty(EXTERNAL_INC_PATH){
        export(EXTERNAL_INC_PATH)
    }

    export(CONFIG)
    export(OUT_DIR)
    export(DEFINES)
    export(QMAKE_CXXFLAGS)
    export(BUILD_TYPE)
    export(LIB_SUFFIX)
    export(BIN_DIR)
    export(OBJ_DIR)
    export(LIB_DIR)

    return (true)
}

#Цель make install для исполняемых файлов
# параметр 1 - путь
# если пуст не пропишет загрузку в устройство
# если статическая либа тоже не пропишет
defineTest(SetDeploy){
    CONFIG(staticlib): return(false)
    isEmpty(DEPLOY_DIR): return (false)

    DEPLOY_DIR = $$1
    #Загрузка на плату если не пустая переменная
    #target.files = $$TARGET
    target.path = $$DEPLOY_DIR
    export(target.files)
    export(target.path)
    export($$target)
    INSTALLS += target
    export(INSTALLS)

    return(true)
}

#установка билиотеки в SDK
#$$1 - PREFIX базовый путь
#установка произойдет в
#<SDK_PATH>/<TARGET>/lib/ - библиотеки
#<SDK_PATH>/<TARGET>/include/ - заголовочные файлы
#TARGET платформа объявленная в MKSPEC в переменной $$_TARGET
defineTest(InstallSDK){

    !CONFIG(staticlib){
        return(false)
    }
    PREFIX = $$1
    
    isEmpty(PREFIX){
        return (false)
    }
    SDK_PATH = $$PREFIX/$$_TARGET
    
    target.path = $$SDK_PATH/lib
    export(target.path)

    INSTALLS += target

    headers.path = $$SDK_PATH/include
    export(headers.path)

    headers.files = ./include/*    
    export(headers.files)

    INSTALLS += headers

    export(INSTALLS)

    return (true)
}

#Добавление путей библиотек и заголовочников
# Вызвывать после объявление типа прокета ConsoleApplication|StaticLibrary
#$$1 - PATH базовый путь к дирректории где должна быть соблюдена следующая структура
# [_TARGET] - если не объявлен то уровень вложенности меньше
#   include
#   lib
defineTest(ImportSDK){
    PATH=$$1
    isEmpty(PATH){
        return(false)
    }

    SetHeadersPath($$clean_path($$PATH/$$_TARGET/include))
    
    contains(TEMPLATE, app){
        SetLibraryPath($$clean_path($$PATH/$$_TARGET/lib))
    }
    return (true)
}
